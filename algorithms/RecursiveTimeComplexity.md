# Time Complexity - Recursion

Представим рекурсивный алгортим. Его сложность будет `O(T)`. Это как правило произведение `R` (количества вызовов рекурсивной функции) и `O(s)` сложности вычисления каждого рекурсивного алгоритма

```
O(T) = R * O(s)
```

**Пример:**

`printReverse` - функция выводящая текст в обратном виде. 

```
printReverse(s) = printReverse(str[1..n]) + print(str[0])
```

- `[1..n]` Это подстрока `str` без первого символа

Функция вызвается **`n`** раз, чему равна длинна `str`. В конце каждого вызова мы просто выводим `str[0]` **`O(1)`**

Итого: 

```
O(printReverse) = n * O(1) = O(n)
```

## Execution Time

Но тем не менее редко бывает что количество вызовов рекурсивной функции имеет прямо пропорционально размеру входного параметра.

Например: `Число Фибоначчи`.

Вначале может показаться что не так то просто просчитать количество рекурсивных вызовов. В таких случаях мы можем обратиться к `Execution Tree`, это древо которое используется для объяснения выполнения рекурсивной функции в частности. Каждый узел древа представляет собой вызов функции. Следовательно общее количество узлов в дереве соответствует количеству рекурсивных вызовов во время выполнения функции. 

Древо выполнения формирует собой `n-ary tree`. В случае фибоначчи это будет `бинарное дерево`

![](https://assets.leetcode.com/uploads/2019/01/25/fibonacci.png)

В полном дереве с `n` уровнем узлов будет **2<sup>n</sup> - 1**. Следовательно максимальное количество вызовов `f(n)` будет **2<sup>n</sup> - 1**. В итоге мы можем подсчитать временную сложность для `fn` - **O(n<sup>2</sup>)**

## Memoization

Мемоизация - может быть примена для оптимизации временной сложности алгоритма. За счет кэширования и переиспользования результата мы можем очень сильно уменьшить количество рекурсивных вызовов, то есть уменьшить количество.

Это сокращение времени следует учитывать во время анализа сложности алгоритма с использованием мемоизации.

Вернемся к примеру с Фибоначчи. С использованием мемоизации мы сохраняем результат вызова функции для каждой `n`. Следовательно каждое число встретится только 1 раз. В результате `f(n)` будет вызванна `n - 1` раз. 

```
O(1) * n = O(n)
```

Мемоизация не только оптимизирует временную сложность алгоритма но и упрощает вычисление временной сложности