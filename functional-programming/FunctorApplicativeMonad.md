# Functor, Applicative, Monad

Самые мощные абстракции, у них немного странные имена (об этом мы поговорим позже), но довольно простое предназначение

Представим функцию от типа `a -> b`

Например 

```
f :: Int -> String
f x = show x
```

В случае если тип находится в контексте `Maybe Int`

Применение функции `f` становится проблемнее, так как тип находится внутри контейнера. 

Мы могли бы реализовать специальную версию этой функции для работы с `Maybe`

```
maybeF :: Maybe Int -> Maybe String
maybeF (Just x) = Just (show x)
maybeF Nothing = Nothing
```

И в случае этой маленькой функции это не было бы большой проблемой, но для более сложных функций все будет не так просто. И мы явно не хотели бы реализовывать подобные версии всех функций.

---

Тут то нам и понадобятся `Functor`, `Applicative`, `Monad`

Эти классы типов играют роль неких адаптеров для наших функций `a -> b`

`Functor` как раз таки нужен нам в случае трансформации `F a -> F b` в контексте 

`Applicative` понадобится нам в двух случах 

1) Первый вариант - когда первый тип находится в контексте в то время как второй вне

`A a -> A b`

2) Второй вариант у нас есть функция находящаяся в контексте 

`A (a -> b)`

`Monad` нужен в случае если результирующий тип находится в контексте 

`a -> M b`

Комбинируя эти классы типов мы можем использовать любые функции вне зависимости от контекста

---

## Откуда такие странные названия?

`Seimgroup`, `Monoid` и теперь `Functor`. Кто вообще это придумал? Все эти названия пришли к нам из областей математики так называемых `Абстрактная алгебра` и `Теория категорий`. Нет необходимости глубоко знать математику чтобы с ними работать. Все эти классы типов представляют собой паттерны функционального программирования. Если вы знаете `Java`, `C#` итд. вы наверняка знакомы с ООП патернами вроде `Observer`, `Singleton`, `Factory`. Все эти паттерны позволяют абстрагировать общие шаблоны программирования. Разница лишь в том что они основываются на математике, а не на каких то шаблонах обнаруженных в коде


